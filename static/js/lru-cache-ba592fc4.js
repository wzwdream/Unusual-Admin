var It=Object.defineProperty;var kt=(u,e,i)=>e in u?It(u,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):u[e]=i;var A=(u,e,i)=>(kt(u,typeof e!="symbol"?e+"":e,i),i),Ot=(u,e,i)=>{if(!e.has(u))throw TypeError("Cannot "+i)};var t=(u,e,i)=>(Ot(u,e,"read from private field"),i?i.call(u):e.get(u)),d=(u,e,i)=>{if(e.has(u))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(u):e.set(u,i)},l=(u,e,i,s)=>(Ot(u,e,"write to private field"),s?s.call(u,i):e.set(u,i),i);var bt=(u,e,i,s)=>({set _(h){l(u,e,h,i)},get _(){return t(u,e,s)}}),o=(u,e,i)=>(Ot(u,e,"access private method"),i);const gt=typeof performance=="object"&&performance&&typeof performance.now=="function"?performance:Date,jt=new Set,Ht=(u,e,i,s)=>{typeof process=="object"&&process&&typeof process.emitWarning=="function"?process.emitWarning(u,e,i,s):console.error(`[${i}] ${e}: ${u}`)},Nt=u=>!jt.has(u),tt=u=>u&&u===Math.floor(u)&&u>0&&isFinite(u),Ut=u=>tt(u)?u<=Math.pow(2,8)?Uint8Array:u<=Math.pow(2,16)?Uint16Array:u<=Math.pow(2,32)?Uint32Array:u<=Number.MAX_SAFE_INTEGER?Ft:null:null;class Ft extends Array{constructor(e){super(e),this.fill(0)}}var at;const ht=class ht{constructor(e,i){A(this,"heap");A(this,"length");if(!t(ht,at))throw new TypeError("instantiate Stack using Stack.create(n)");this.heap=new i(e),this.length=0}static create(e){const i=Ut(e);if(!i)return[];l(ht,at,!0);const s=new ht(e,i);return l(ht,at,!1),s}push(e){this.heap[this.length++]=e}pop(){return this.heap[--this.length]}};at=new WeakMap,d(ht,at,!1);let Et=ht;var M,R,B,I,ft,b,k,F,S,c,v,x,E,z,H,O,Z,J,N,$,st,W,wt,Wt,rt,K,St,L,Tt,Gt,ot,ct,_t,q,et,X,it,yt,Dt,ut,At,dt,zt,w,_,mt,Ct,lt,pt;const Rt=class Rt{constructor(e){d(this,wt);d(this,Tt);d(this,q);d(this,X);d(this,yt);d(this,ut);d(this,dt);d(this,w);d(this,mt);d(this,lt);d(this,M,void 0);d(this,R,void 0);d(this,B,void 0);d(this,I,void 0);d(this,ft,void 0);A(this,"ttl");A(this,"ttlResolution");A(this,"ttlAutopurge");A(this,"updateAgeOnGet");A(this,"updateAgeOnHas");A(this,"allowStale");A(this,"noDisposeOnSet");A(this,"noUpdateTTL");A(this,"maxEntrySize");A(this,"sizeCalculation");A(this,"noDeleteOnFetchRejection");A(this,"noDeleteOnStaleGet");A(this,"allowStaleOnFetchAbort");A(this,"allowStaleOnFetchRejection");A(this,"ignoreFetchAbort");d(this,b,void 0);d(this,k,void 0);d(this,F,void 0);d(this,S,void 0);d(this,c,void 0);d(this,v,void 0);d(this,x,void 0);d(this,E,void 0);d(this,z,void 0);d(this,H,void 0);d(this,O,void 0);d(this,Z,void 0);d(this,J,void 0);d(this,N,void 0);d(this,$,void 0);d(this,st,void 0);d(this,W,void 0);d(this,rt,()=>{});d(this,K,()=>{});d(this,St,()=>{});d(this,L,()=>!1);d(this,ot,e=>{});d(this,ct,(e,i,s)=>{});d(this,_t,(e,i,s,h)=>{if(s||h)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0});const{max:i=0,ttl:s,ttlResolution:h=1,ttlAutopurge:n,updateAgeOnGet:r,updateAgeOnHas:a,allowStale:f,dispose:D,disposeAfter:P,noDisposeOnSet:y,noUpdateTTL:Q,maxSize:j=0,maxEntrySize:V=0,sizeCalculation:g,fetchMethod:m,noDeleteOnFetchRejection:p,noDeleteOnStaleGet:U,allowStaleOnFetchRejection:C,allowStaleOnFetchAbort:T,ignoreFetchAbort:G}=e;if(i!==0&&!tt(i))throw new TypeError("max option must be a nonnegative integer");const nt=i?Ut(i):Array;if(!nt)throw new Error("invalid max value: "+i);if(l(this,M,i),l(this,R,j),this.maxEntrySize=V||t(this,R),this.sizeCalculation=g,this.sizeCalculation){if(!t(this,R)&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if(typeof this.sizeCalculation!="function")throw new TypeError("sizeCalculation set to non-function")}if(m!==void 0&&typeof m!="function")throw new TypeError("fetchMethod must be a function if specified");if(l(this,ft,m),l(this,st,!!m),l(this,F,new Map),l(this,S,new Array(i).fill(void 0)),l(this,c,new Array(i).fill(void 0)),l(this,v,new nt(i)),l(this,x,new nt(i)),l(this,E,0),l(this,z,0),l(this,H,Et.create(i)),l(this,b,0),l(this,k,0),typeof D=="function"&&l(this,B,D),typeof P=="function"?(l(this,I,P),l(this,O,[])):(l(this,I,void 0),l(this,O,void 0)),l(this,$,!!t(this,B)),l(this,W,!!t(this,I)),this.noDisposeOnSet=!!y,this.noUpdateTTL=!!Q,this.noDeleteOnFetchRejection=!!p,this.allowStaleOnFetchRejection=!!C,this.allowStaleOnFetchAbort=!!T,this.ignoreFetchAbort=!!G,this.maxEntrySize!==0){if(t(this,R)!==0&&!tt(t(this,R)))throw new TypeError("maxSize must be a positive integer if specified");if(!tt(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");o(this,Tt,Gt).call(this)}if(this.allowStale=!!f,this.noDeleteOnStaleGet=!!U,this.updateAgeOnGet=!!r,this.updateAgeOnHas=!!a,this.ttlResolution=tt(h)||h===0?h:1,this.ttlAutopurge=!!n,this.ttl=s||0,this.ttl){if(!tt(this.ttl))throw new TypeError("ttl must be a positive integer if specified");o(this,wt,Wt).call(this)}if(t(this,M)===0&&this.ttl===0&&t(this,R)===0)throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!t(this,M)&&!t(this,R)){const Y="LRU_CACHE_UNBOUNDED";Nt(Y)&&(jt.add(Y),Ht("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",Y,Rt))}}static unsafeExposeInternals(e){return{starts:t(e,J),ttls:t(e,N),sizes:t(e,Z),keyMap:t(e,F),keyList:t(e,S),valList:t(e,c),next:t(e,v),prev:t(e,x),get head(){return t(e,E)},get tail(){return t(e,z)},free:t(e,H),isBackgroundFetch:i=>{var s;return o(s=e,w,_).call(s,i)},backgroundFetch:(i,s,h,n)=>{var r;return o(r=e,dt,zt).call(r,i,s,h,n)},moveToTail:i=>{var s;return o(s=e,lt,pt).call(s,i)},indexes:i=>{var s;return o(s=e,q,et).call(s,i)},rindexes:i=>{var s;return o(s=e,X,it).call(s,i)},isStale:i=>{var s;return t(s=e,L).call(s,i)}}}get max(){return t(this,M)}get maxSize(){return t(this,R)}get calculatedSize(){return t(this,k)}get size(){return t(this,b)}get fetchMethod(){return t(this,ft)}get dispose(){return t(this,B)}get disposeAfter(){return t(this,I)}getRemainingTTL(e){return t(this,F).has(e)?1/0:0}*entries(){for(const e of o(this,q,et).call(this))t(this,c)[e]!==void 0&&t(this,S)[e]!==void 0&&!o(this,w,_).call(this,t(this,c)[e])&&(yield[t(this,S)[e],t(this,c)[e]])}*rentries(){for(const e of o(this,X,it).call(this))t(this,c)[e]!==void 0&&t(this,S)[e]!==void 0&&!o(this,w,_).call(this,t(this,c)[e])&&(yield[t(this,S)[e],t(this,c)[e]])}*keys(){for(const e of o(this,q,et).call(this)){const i=t(this,S)[e];i!==void 0&&!o(this,w,_).call(this,t(this,c)[e])&&(yield i)}}*rkeys(){for(const e of o(this,X,it).call(this)){const i=t(this,S)[e];i!==void 0&&!o(this,w,_).call(this,t(this,c)[e])&&(yield i)}}*values(){for(const e of o(this,q,et).call(this))t(this,c)[e]!==void 0&&!o(this,w,_).call(this,t(this,c)[e])&&(yield t(this,c)[e])}*rvalues(){for(const e of o(this,X,it).call(this))t(this,c)[e]!==void 0&&!o(this,w,_).call(this,t(this,c)[e])&&(yield t(this,c)[e])}[Symbol.iterator](){return this.entries()}find(e,i={}){for(const s of o(this,q,et).call(this)){const h=t(this,c)[s],n=o(this,w,_).call(this,h)?h.__staleWhileFetching:h;if(n!==void 0&&e(n,t(this,S)[s],this))return this.get(t(this,S)[s],i)}}forEach(e,i=this){for(const s of o(this,q,et).call(this)){const h=t(this,c)[s],n=o(this,w,_).call(this,h)?h.__staleWhileFetching:h;n!==void 0&&e.call(i,n,t(this,S)[s],this)}}rforEach(e,i=this){for(const s of o(this,X,it).call(this)){const h=t(this,c)[s],n=o(this,w,_).call(this,h)?h.__staleWhileFetching:h;n!==void 0&&e.call(i,n,t(this,S)[s],this)}}purgeStale(){let e=!1;for(const i of o(this,X,it).call(this,{allowStale:!0}))t(this,L).call(this,i)&&(this.delete(t(this,S)[i]),e=!0);return e}dump(){const e=[];for(const i of o(this,q,et).call(this,{allowStale:!0})){const s=t(this,S)[i],h=t(this,c)[i],n=o(this,w,_).call(this,h)?h.__staleWhileFetching:h;if(n===void 0||s===void 0)continue;const r={value:n};if(t(this,N)&&t(this,J)){r.ttl=t(this,N)[i];const a=gt.now()-t(this,J)[i];r.start=Math.floor(Date.now()-a)}t(this,Z)&&(r.size=t(this,Z)[i]),e.unshift([s,r])}return e}load(e){this.clear();for(const[i,s]of e){if(s.start){const h=Date.now()-s.start;s.start=gt.now()-h}this.set(i,s.value,s)}}set(e,i,s={}){var Q,j,V;const{ttl:h=this.ttl,start:n,noDisposeOnSet:r=this.noDisposeOnSet,sizeCalculation:a=this.sizeCalculation,status:f}=s;let{noUpdateTTL:D=this.noUpdateTTL}=s;const P=t(this,_t).call(this,e,i,s.size||0,a);if(this.maxEntrySize&&P>this.maxEntrySize)return f&&(f.set="miss",f.maxEntrySizeExceeded=!0),this.delete(e),this;let y=t(this,b)===0?void 0:t(this,F).get(e);if(y===void 0)y=t(this,b)===0?t(this,z):t(this,H).length!==0?t(this,H).pop():t(this,b)===t(this,M)?o(this,ut,At).call(this,!1):t(this,b),t(this,S)[y]=e,t(this,c)[y]=i,t(this,F).set(e,y),t(this,v)[t(this,z)]=y,t(this,x)[y]=t(this,z),l(this,z,y),bt(this,b)._++,t(this,ct).call(this,y,P,f),f&&(f.set="add"),D=!1;else{o(this,lt,pt).call(this,y);const g=t(this,c)[y];if(i!==g){if(t(this,st)&&o(this,w,_).call(this,g)?g.__abortController.abort(new Error("replaced")):r||(t(this,$)&&((Q=t(this,B))==null||Q.call(this,g,e,"set")),t(this,W)&&((j=t(this,O))==null||j.push([g,e,"set"]))),t(this,ot).call(this,y),t(this,ct).call(this,y,P,f),t(this,c)[y]=i,f){f.set="replace";const m=g&&o(this,w,_).call(this,g)?g.__staleWhileFetching:g;m!==void 0&&(f.oldValue=m)}}else f&&(f.set="update")}if(h!==0&&!t(this,N)&&o(this,wt,Wt).call(this),t(this,N)&&(D||t(this,St).call(this,y,h,n),f&&t(this,K).call(this,f,y)),!r&&t(this,W)&&t(this,O)){const g=t(this,O);let m;for(;m=g==null?void 0:g.shift();)(V=t(this,I))==null||V.call(this,...m)}return this}pop(){var e;try{for(;t(this,b);){const i=t(this,c)[t(this,E)];if(o(this,ut,At).call(this,!0),o(this,w,_).call(this,i)){if(i.__staleWhileFetching)return i.__staleWhileFetching}else if(i!==void 0)return i}}finally{if(t(this,W)&&t(this,O)){const i=t(this,O);let s;for(;s=i==null?void 0:i.shift();)(e=t(this,I))==null||e.call(this,...s)}}}has(e,i={}){const{updateAgeOnHas:s=this.updateAgeOnHas,status:h}=i,n=t(this,F).get(e);if(n!==void 0){const r=t(this,c)[n];if(o(this,w,_).call(this,r)&&r.__staleWhileFetching===void 0)return!1;if(t(this,L).call(this,n))h&&(h.has="stale",t(this,K).call(this,h,n));else return s&&t(this,rt).call(this,n),h&&(h.has="hit",t(this,K).call(this,h,n)),!0}else h&&(h.has="miss");return!1}peek(e,i={}){const{allowStale:s=this.allowStale}=i,h=t(this,F).get(e);if(h!==void 0&&(s||!t(this,L).call(this,h))){const n=t(this,c)[h];return o(this,w,_).call(this,n)?n.__staleWhileFetching:n}}async fetch(e,i={}){const{allowStale:s=this.allowStale,updateAgeOnGet:h=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,ttl:r=this.ttl,noDisposeOnSet:a=this.noDisposeOnSet,size:f=0,sizeCalculation:D=this.sizeCalculation,noUpdateTTL:P=this.noUpdateTTL,noDeleteOnFetchRejection:y=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:Q=this.allowStaleOnFetchRejection,ignoreFetchAbort:j=this.ignoreFetchAbort,allowStaleOnFetchAbort:V=this.allowStaleOnFetchAbort,context:g,forceRefresh:m=!1,status:p,signal:U}=i;if(!t(this,st))return p&&(p.fetch="get"),this.get(e,{allowStale:s,updateAgeOnGet:h,noDeleteOnStaleGet:n,status:p});const C={allowStale:s,updateAgeOnGet:h,noDeleteOnStaleGet:n,ttl:r,noDisposeOnSet:a,size:f,sizeCalculation:D,noUpdateTTL:P,noDeleteOnFetchRejection:y,allowStaleOnFetchRejection:Q,allowStaleOnFetchAbort:V,ignoreFetchAbort:j,status:p,signal:U};let T=t(this,F).get(e);if(T===void 0){p&&(p.fetch="miss");const G=o(this,dt,zt).call(this,e,T,C,g);return G.__returned=G}else{const G=t(this,c)[T];if(o(this,w,_).call(this,G)){const Lt=s&&G.__staleWhileFetching!==void 0;return p&&(p.fetch="inflight",Lt&&(p.returnedStale=!0)),Lt?G.__staleWhileFetching:G.__returned=G}const nt=t(this,L).call(this,T);if(!m&&!nt)return p&&(p.fetch="hit"),o(this,lt,pt).call(this,T),h&&t(this,rt).call(this,T),p&&t(this,K).call(this,p,T),G;const Y=o(this,dt,zt).call(this,e,T,C,g),xt=Y.__staleWhileFetching!==void 0&&s;return p&&(p.fetch=nt?"stale":"refresh",xt&&nt&&(p.returnedStale=!0)),xt?Y.__staleWhileFetching:Y.__returned=Y}}get(e,i={}){const{allowStale:s=this.allowStale,updateAgeOnGet:h=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,status:r}=i,a=t(this,F).get(e);if(a!==void 0){const f=t(this,c)[a],D=o(this,w,_).call(this,f);return r&&t(this,K).call(this,r,a),t(this,L).call(this,a)?(r&&(r.get="stale"),D?(r&&s&&f.__staleWhileFetching!==void 0&&(r.returnedStale=!0),s?f.__staleWhileFetching:void 0):(n||this.delete(e),r&&s&&(r.returnedStale=!0),s?f:void 0)):(r&&(r.get="hit"),D?f.__staleWhileFetching:(o(this,lt,pt).call(this,a),h&&t(this,rt).call(this,a),f))}else r&&(r.get="miss")}delete(e){var s,h,n,r;let i=!1;if(t(this,b)!==0){const a=t(this,F).get(e);if(a!==void 0)if(i=!0,t(this,b)===1)this.clear();else{t(this,ot).call(this,a);const f=t(this,c)[a];o(this,w,_).call(this,f)?f.__abortController.abort(new Error("deleted")):(t(this,$)||t(this,W))&&(t(this,$)&&((s=t(this,B))==null||s.call(this,f,e,"delete")),t(this,W)&&((h=t(this,O))==null||h.push([f,e,"delete"]))),t(this,F).delete(e),t(this,S)[a]=void 0,t(this,c)[a]=void 0,a===t(this,z)?l(this,z,t(this,x)[a]):a===t(this,E)?l(this,E,t(this,v)[a]):(t(this,v)[t(this,x)[a]]=t(this,v)[a],t(this,x)[t(this,v)[a]]=t(this,x)[a]),bt(this,b)._--,t(this,H).push(a)}}if(t(this,W)&&((n=t(this,O))!=null&&n.length)){const a=t(this,O);let f;for(;f=a==null?void 0:a.shift();)(r=t(this,I))==null||r.call(this,...f)}return i}clear(){var e,i,s;for(const h of o(this,X,it).call(this,{allowStale:!0})){const n=t(this,c)[h];if(o(this,w,_).call(this,n))n.__abortController.abort(new Error("deleted"));else{const r=t(this,S)[h];t(this,$)&&((e=t(this,B))==null||e.call(this,n,r,"delete")),t(this,W)&&((i=t(this,O))==null||i.push([n,r,"delete"]))}}if(t(this,F).clear(),t(this,c).fill(void 0),t(this,S).fill(void 0),t(this,N)&&t(this,J)&&(t(this,N).fill(0),t(this,J).fill(0)),t(this,Z)&&t(this,Z).fill(0),l(this,E,0),l(this,z,0),t(this,H).length=0,l(this,k,0),l(this,b,0),t(this,W)&&t(this,O)){const h=t(this,O);let n;for(;n=h==null?void 0:h.shift();)(s=t(this,I))==null||s.call(this,...n)}}};M=new WeakMap,R=new WeakMap,B=new WeakMap,I=new WeakMap,ft=new WeakMap,b=new WeakMap,k=new WeakMap,F=new WeakMap,S=new WeakMap,c=new WeakMap,v=new WeakMap,x=new WeakMap,E=new WeakMap,z=new WeakMap,H=new WeakMap,O=new WeakMap,Z=new WeakMap,J=new WeakMap,N=new WeakMap,$=new WeakMap,st=new WeakMap,W=new WeakMap,wt=new WeakSet,Wt=function(){const e=new Ft(t(this,M)),i=new Ft(t(this,M));l(this,N,e),l(this,J,i),l(this,St,(n,r,a=gt.now())=>{if(i[n]=r!==0?a:0,e[n]=r,r!==0&&this.ttlAutopurge){const f=setTimeout(()=>{t(this,L).call(this,n)&&this.delete(t(this,S)[n])},r+1);f.unref&&f.unref()}}),l(this,rt,n=>{i[n]=e[n]!==0?gt.now():0}),l(this,K,(n,r)=>{if(e[r]){const a=e[r],f=i[r];n.ttl=a,n.start=f,n.now=s||h(),n.remainingTTL=n.now+a-f}});let s=0;const h=()=>{const n=gt.now();if(this.ttlResolution>0){s=n;const r=setTimeout(()=>s=0,this.ttlResolution);r.unref&&r.unref()}return n};this.getRemainingTTL=n=>{const r=t(this,F).get(n);return r===void 0?0:e[r]===0||i[r]===0?1/0:i[r]+e[r]-(s||h())},l(this,L,n=>e[n]!==0&&i[n]!==0&&(s||h())-i[n]>e[n])},rt=new WeakMap,K=new WeakMap,St=new WeakMap,L=new WeakMap,Tt=new WeakSet,Gt=function(){const e=new Ft(t(this,M));l(this,k,0),l(this,Z,e),l(this,ot,i=>{l(this,k,t(this,k)-e[i]),e[i]=0}),l(this,_t,(i,s,h,n)=>{if(o(this,w,_).call(this,s))return 0;if(!tt(h))if(n){if(typeof n!="function")throw new TypeError("sizeCalculation must be a function");if(h=n(s,i),!tt(h))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}else throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");return h}),l(this,ct,(i,s,h)=>{if(e[i]=s,t(this,R)){const n=t(this,R)-e[i];for(;t(this,k)>n;)o(this,ut,At).call(this,!0)}l(this,k,t(this,k)+e[i]),h&&(h.entrySize=s,h.totalCalculatedSize=t(this,k))})},ot=new WeakMap,ct=new WeakMap,_t=new WeakMap,q=new WeakSet,et=function*({allowStale:e=this.allowStale}={}){if(t(this,b))for(let i=t(this,z);!(!o(this,yt,Dt).call(this,i)||((e||!t(this,L).call(this,i))&&(yield i),i===t(this,E)));)i=t(this,x)[i]},X=new WeakSet,it=function*({allowStale:e=this.allowStale}={}){if(t(this,b))for(let i=t(this,E);!(!o(this,yt,Dt).call(this,i)||((e||!t(this,L).call(this,i))&&(yield i),i===t(this,z)));)i=t(this,v)[i]},yt=new WeakSet,Dt=function(e){return e!==void 0&&t(this,F).get(t(this,S)[e])===e},ut=new WeakSet,At=function(e){var n,r;const i=t(this,E),s=t(this,S)[i],h=t(this,c)[i];return t(this,st)&&o(this,w,_).call(this,h)?h.__abortController.abort(new Error("evicted")):(t(this,$)||t(this,W))&&(t(this,$)&&((n=t(this,B))==null||n.call(this,h,s,"evict")),t(this,W)&&((r=t(this,O))==null||r.push([h,s,"evict"]))),t(this,ot).call(this,i),e&&(t(this,S)[i]=void 0,t(this,c)[i]=void 0,t(this,H).push(i)),t(this,b)===1?(l(this,E,l(this,z,0)),t(this,H).length=0):l(this,E,t(this,v)[i]),t(this,F).delete(s),bt(this,b)._--,i},dt=new WeakSet,zt=function(e,i,s,h){const n=i===void 0?void 0:t(this,c)[i];if(o(this,w,_).call(this,n))return n;const r=new AbortController,{signal:a}=s;a==null||a.addEventListener("abort",()=>r.abort(a.reason),{signal:r.signal});const f={signal:r.signal,options:s,context:h},D=(g,m=!1)=>{const{aborted:p}=r.signal,U=s.ignoreFetchAbort&&g!==void 0;if(s.status&&(p&&!m?(s.status.fetchAborted=!0,s.status.fetchError=r.signal.reason,U&&(s.status.fetchAbortIgnored=!0)):s.status.fetchResolved=!0),p&&!U&&!m)return y(r.signal.reason);const C=j;return t(this,c)[i]===j&&(g===void 0?C.__staleWhileFetching?t(this,c)[i]=C.__staleWhileFetching:this.delete(e):(s.status&&(s.status.fetchUpdated=!0),this.set(e,g,f.options))),g},P=g=>(s.status&&(s.status.fetchRejected=!0,s.status.fetchError=g),y(g)),y=g=>{const{aborted:m}=r.signal,p=m&&s.allowStaleOnFetchAbort,U=p||s.allowStaleOnFetchRejection,C=U||s.noDeleteOnFetchRejection,T=j;if(t(this,c)[i]===j&&(!C||T.__staleWhileFetching===void 0?this.delete(e):p||(t(this,c)[i]=T.__staleWhileFetching)),U)return s.status&&T.__staleWhileFetching!==void 0&&(s.status.returnedStale=!0),T.__staleWhileFetching;if(T.__returned===T)throw g},Q=(g,m)=>{var U;const p=(U=t(this,ft))==null?void 0:U.call(this,e,n,f);p&&p instanceof Promise&&p.then(C=>g(C),m),r.signal.addEventListener("abort",()=>{(!s.ignoreFetchAbort||s.allowStaleOnFetchAbort)&&(g(),s.allowStaleOnFetchAbort&&(g=C=>D(C,!0)))})};s.status&&(s.status.fetchDispatched=!0);const j=new Promise(Q).then(D,P),V=Object.assign(j,{__abortController:r,__staleWhileFetching:n,__returned:void 0});return i===void 0?(this.set(e,V,{...f.options,status:void 0}),i=t(this,F).get(e)):t(this,c)[i]=V,V},w=new WeakSet,_=function(e){if(!t(this,st))return!1;const i=e;return!!i&&i instanceof Promise&&i.hasOwnProperty("__staleWhileFetching")&&i.__abortController instanceof AbortController},mt=new WeakSet,Ct=function(e,i){t(this,x)[i]=e,t(this,v)[e]=i},lt=new WeakSet,pt=function(e){e!==t(this,z)&&(e===t(this,E)?l(this,E,t(this,v)[e]):o(this,mt,Ct).call(this,t(this,x)[e],t(this,v)[e]),o(this,mt,Ct).call(this,t(this,z),e),l(this,z,e))};let vt=Rt;const Vt=vt;export{Vt as x};
