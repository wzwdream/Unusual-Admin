var Vt=Object.defineProperty;var Bt=(c,e,i)=>e in c?Vt(c,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):c[e]=i;var _=(c,e,i)=>(Bt(c,typeof e!="symbol"?e+"":e,i),i),Et=(c,e,i)=>{if(!e.has(c))throw TypeError("Cannot "+i)};var t=(c,e,i)=>(Et(c,e,"read from private field"),i?i.call(c):e.get(c)),g=(c,e,i)=>{if(e.has(c))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(c):e.set(c,i)},a=(c,e,i,s)=>(Et(c,e,"write to private field"),s?s.call(c,i):e.set(c,i),i);var At=(c,e,i,s)=>({set _(h){a(c,e,h,i)},get _(){return t(c,e,s)}}),o=(c,e,i)=>(Et(c,e,"access private method"),i);const at=typeof performance=="object"&&performance&&typeof performance.now=="function"?performance:Date,Nt=new Set,vt=typeof process=="object"&&process?process:{},Mt=(c,e,i,s)=>{typeof vt.emitWarning=="function"?vt.emitWarning(c,e,i,s):console.error(`[${i}] ${e}: ${c}`)};let Tt=globalThis.AbortController,Gt=globalThis.AbortSignal;var jt;if(typeof Tt>"u"){Gt=class{constructor(){_(this,"onabort");_(this,"_onabort",[]);_(this,"reason");_(this,"aborted",!1)}addEventListener(s,h){this._onabort.push(h)}},Tt=class{constructor(){_(this,"signal",new Gt);e()}abort(s){var h,n;if(!this.signal.aborted){this.signal.reason=s,this.signal.aborted=!0;for(const r of this.signal._onabort)r(s);(n=(h=this.signal).onabort)==null||n.call(h,s)}}};let c=((jt=vt.env)==null?void 0:jt.LRU_CACHE_IGNORE_AC_WARNING)!=="1";const e=()=>{c&&(c=!1,Mt("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",e))}}const $t=c=>!Nt.has(c),tt=c=>c&&c===Math.floor(c)&&c>0&&isFinite(c),Pt=c=>tt(c)?c<=Math.pow(2,8)?Uint8Array:c<=Math.pow(2,16)?Uint16Array:c<=Math.pow(2,32)?Uint32Array:c<=Number.MAX_SAFE_INTEGER?mt:null:null;class mt extends Array{constructor(e){super(e),this.fill(0)}}var ft;const ht=class ht{constructor(e,i){_(this,"heap");_(this,"length");if(!t(ht,ft))throw new TypeError("instantiate Stack using Stack.create(n)");this.heap=new i(e),this.length=0}static create(e){const i=Pt(e);if(!i)return[];a(ht,ft,!0);const s=new ht(e,i);return a(ht,ft,!1),s}push(e){this.heap[this.length++]=e}pop(){return this.heap[--this.length]}};ft=new WeakMap,g(ht,ft,!1);let Ct=ht;var M,L,P,H,ct,O,k,m,S,u,R,x,C,T,V,z,B,$,U,q,st,W,wt,Rt,rt,J,St,G,zt,Ht,ot,ut,_t,Y,et,Z,it,bt,Wt,qt,dt,Ft,gt,Ot,p,w,yt,Dt,lt,pt;const Lt=class Lt{constructor(e){g(this,wt);g(this,zt);g(this,Y);g(this,Z);g(this,bt);g(this,dt);g(this,gt);g(this,p);g(this,yt);g(this,lt);g(this,M,void 0);g(this,L,void 0);g(this,P,void 0);g(this,H,void 0);g(this,ct,void 0);_(this,"ttl");_(this,"ttlResolution");_(this,"ttlAutopurge");_(this,"updateAgeOnGet");_(this,"updateAgeOnHas");_(this,"allowStale");_(this,"noDisposeOnSet");_(this,"noUpdateTTL");_(this,"maxEntrySize");_(this,"sizeCalculation");_(this,"noDeleteOnFetchRejection");_(this,"noDeleteOnStaleGet");_(this,"allowStaleOnFetchAbort");_(this,"allowStaleOnFetchRejection");_(this,"ignoreFetchAbort");g(this,O,void 0);g(this,k,void 0);g(this,m,void 0);g(this,S,void 0);g(this,u,void 0);g(this,R,void 0);g(this,x,void 0);g(this,C,void 0);g(this,T,void 0);g(this,V,void 0);g(this,z,void 0);g(this,B,void 0);g(this,$,void 0);g(this,U,void 0);g(this,q,void 0);g(this,st,void 0);g(this,W,void 0);g(this,rt,()=>{});g(this,J,()=>{});g(this,St,()=>{});g(this,G,()=>!1);g(this,ot,e=>{});g(this,ut,(e,i,s)=>{});g(this,_t,(e,i,s,h)=>{if(s||h)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0});_(this,qt,"LRUCache");const{max:i=0,ttl:s,ttlResolution:h=1,ttlAutopurge:n,updateAgeOnGet:r,updateAgeOnHas:l,allowStale:f,dispose:F,disposeAfter:I,noDisposeOnSet:b,noUpdateTTL:K,maxSize:j=0,maxEntrySize:X=0,sizeCalculation:A,fetchMethod:v,noDeleteOnFetchRejection:d,noDeleteOnStaleGet:y,allowStaleOnFetchRejection:D,allowStaleOnFetchAbort:E,ignoreFetchAbort:N}=e;if(i!==0&&!tt(i))throw new TypeError("max option must be a nonnegative integer");const nt=i?Pt(i):Array;if(!nt)throw new Error("invalid max value: "+i);if(a(this,M,i),a(this,L,j),this.maxEntrySize=X||t(this,L),this.sizeCalculation=A,this.sizeCalculation){if(!t(this,L)&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if(typeof this.sizeCalculation!="function")throw new TypeError("sizeCalculation set to non-function")}if(v!==void 0&&typeof v!="function")throw new TypeError("fetchMethod must be a function if specified");if(a(this,ct,v),a(this,st,!!v),a(this,m,new Map),a(this,S,new Array(i).fill(void 0)),a(this,u,new Array(i).fill(void 0)),a(this,R,new nt(i)),a(this,x,new nt(i)),a(this,C,0),a(this,T,0),a(this,V,Ct.create(i)),a(this,O,0),a(this,k,0),typeof F=="function"&&a(this,P,F),typeof I=="function"?(a(this,H,I),a(this,z,[])):(a(this,H,void 0),a(this,z,void 0)),a(this,q,!!t(this,P)),a(this,W,!!t(this,H)),this.noDisposeOnSet=!!b,this.noUpdateTTL=!!K,this.noDeleteOnFetchRejection=!!d,this.allowStaleOnFetchRejection=!!D,this.allowStaleOnFetchAbort=!!E,this.ignoreFetchAbort=!!N,this.maxEntrySize!==0){if(t(this,L)!==0&&!tt(t(this,L)))throw new TypeError("maxSize must be a positive integer if specified");if(!tt(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");o(this,zt,Ht).call(this)}if(this.allowStale=!!f,this.noDeleteOnStaleGet=!!y,this.updateAgeOnGet=!!r,this.updateAgeOnHas=!!l,this.ttlResolution=tt(h)||h===0?h:1,this.ttlAutopurge=!!n,this.ttl=s||0,this.ttl){if(!tt(this.ttl))throw new TypeError("ttl must be a positive integer if specified");o(this,wt,Rt).call(this)}if(t(this,M)===0&&this.ttl===0&&t(this,L)===0)throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!t(this,M)&&!t(this,L)){const Q="LRU_CACHE_UNBOUNDED";$t(Q)&&(Nt.add(Q),Mt("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",Q,Lt))}}static unsafeExposeInternals(e){return{starts:t(e,$),ttls:t(e,U),sizes:t(e,B),keyMap:t(e,m),keyList:t(e,S),valList:t(e,u),next:t(e,R),prev:t(e,x),get head(){return t(e,C)},get tail(){return t(e,T)},free:t(e,V),isBackgroundFetch:i=>{var s;return o(s=e,p,w).call(s,i)},backgroundFetch:(i,s,h,n)=>{var r;return o(r=e,gt,Ot).call(r,i,s,h,n)},moveToTail:i=>{var s;return o(s=e,lt,pt).call(s,i)},indexes:i=>{var s;return o(s=e,Y,et).call(s,i)},rindexes:i=>{var s;return o(s=e,Z,it).call(s,i)},isStale:i=>{var s;return t(s=e,G).call(s,i)}}}get max(){return t(this,M)}get maxSize(){return t(this,L)}get calculatedSize(){return t(this,k)}get size(){return t(this,O)}get fetchMethod(){return t(this,ct)}get dispose(){return t(this,P)}get disposeAfter(){return t(this,H)}getRemainingTTL(e){return t(this,m).has(e)?1/0:0}*entries(){for(const e of o(this,Y,et).call(this))t(this,u)[e]!==void 0&&t(this,S)[e]!==void 0&&!o(this,p,w).call(this,t(this,u)[e])&&(yield[t(this,S)[e],t(this,u)[e]])}*rentries(){for(const e of o(this,Z,it).call(this))t(this,u)[e]!==void 0&&t(this,S)[e]!==void 0&&!o(this,p,w).call(this,t(this,u)[e])&&(yield[t(this,S)[e],t(this,u)[e]])}*keys(){for(const e of o(this,Y,et).call(this)){const i=t(this,S)[e];i!==void 0&&!o(this,p,w).call(this,t(this,u)[e])&&(yield i)}}*rkeys(){for(const e of o(this,Z,it).call(this)){const i=t(this,S)[e];i!==void 0&&!o(this,p,w).call(this,t(this,u)[e])&&(yield i)}}*values(){for(const e of o(this,Y,et).call(this))t(this,u)[e]!==void 0&&!o(this,p,w).call(this,t(this,u)[e])&&(yield t(this,u)[e])}*rvalues(){for(const e of o(this,Z,it).call(this))t(this,u)[e]!==void 0&&!o(this,p,w).call(this,t(this,u)[e])&&(yield t(this,u)[e])}[Symbol.iterator](){return this.entries()}find(e,i={}){for(const s of o(this,Y,et).call(this)){const h=t(this,u)[s],n=o(this,p,w).call(this,h)?h.__staleWhileFetching:h;if(n!==void 0&&e(n,t(this,S)[s],this))return this.get(t(this,S)[s],i)}}forEach(e,i=this){for(const s of o(this,Y,et).call(this)){const h=t(this,u)[s],n=o(this,p,w).call(this,h)?h.__staleWhileFetching:h;n!==void 0&&e.call(i,n,t(this,S)[s],this)}}rforEach(e,i=this){for(const s of o(this,Z,it).call(this)){const h=t(this,u)[s],n=o(this,p,w).call(this,h)?h.__staleWhileFetching:h;n!==void 0&&e.call(i,n,t(this,S)[s],this)}}purgeStale(){let e=!1;for(const i of o(this,Z,it).call(this,{allowStale:!0}))t(this,G).call(this,i)&&(this.delete(t(this,S)[i]),e=!0);return e}info(e){const i=t(this,m).get(e);if(i===void 0)return;const s=t(this,u)[i],h=o(this,p,w).call(this,s)?s.__staleWhileFetching:s;if(h===void 0)return;const n={value:h};if(t(this,U)&&t(this,$)){const r=t(this,U)[i],l=t(this,$)[i];if(r&&l){const f=r-(at.now()-l);n.ttl=f,n.start=Date.now()}}return t(this,B)&&(n.size=t(this,B)[i]),n}dump(){const e=[];for(const i of o(this,Y,et).call(this,{allowStale:!0})){const s=t(this,S)[i],h=t(this,u)[i],n=o(this,p,w).call(this,h)?h.__staleWhileFetching:h;if(n===void 0||s===void 0)continue;const r={value:n};if(t(this,U)&&t(this,$)){r.ttl=t(this,U)[i];const l=at.now()-t(this,$)[i];r.start=Math.floor(Date.now()-l)}t(this,B)&&(r.size=t(this,B)[i]),e.unshift([s,r])}return e}load(e){this.clear();for(const[i,s]of e){if(s.start){const h=Date.now()-s.start;s.start=at.now()-h}this.set(i,s.value,s)}}set(e,i,s={}){var K,j,X,A,v;if(i===void 0)return this.delete(e),this;const{ttl:h=this.ttl,start:n,noDisposeOnSet:r=this.noDisposeOnSet,sizeCalculation:l=this.sizeCalculation,status:f}=s;let{noUpdateTTL:F=this.noUpdateTTL}=s;const I=t(this,_t).call(this,e,i,s.size||0,l);if(this.maxEntrySize&&I>this.maxEntrySize)return f&&(f.set="miss",f.maxEntrySizeExceeded=!0),this.delete(e),this;let b=t(this,O)===0?void 0:t(this,m).get(e);if(b===void 0)b=t(this,O)===0?t(this,T):t(this,V).length!==0?t(this,V).pop():t(this,O)===t(this,M)?o(this,dt,Ft).call(this,!1):t(this,O),t(this,S)[b]=e,t(this,u)[b]=i,t(this,m).set(e,b),t(this,R)[t(this,T)]=b,t(this,x)[b]=t(this,T),a(this,T,b),At(this,O)._++,t(this,ut).call(this,b,I,f),f&&(f.set="add"),F=!1;else{o(this,lt,pt).call(this,b);const d=t(this,u)[b];if(i!==d){if(t(this,st)&&o(this,p,w).call(this,d)){d.__abortController.abort(new Error("replaced"));const{__staleWhileFetching:y}=d;y!==void 0&&!r&&(t(this,q)&&((K=t(this,P))==null||K.call(this,y,e,"set")),t(this,W)&&((j=t(this,z))==null||j.push([y,e,"set"])))}else r||(t(this,q)&&((X=t(this,P))==null||X.call(this,d,e,"set")),t(this,W)&&((A=t(this,z))==null||A.push([d,e,"set"])));if(t(this,ot).call(this,b),t(this,ut).call(this,b,I,f),t(this,u)[b]=i,f){f.set="replace";const y=d&&o(this,p,w).call(this,d)?d.__staleWhileFetching:d;y!==void 0&&(f.oldValue=y)}}else f&&(f.set="update")}if(h!==0&&!t(this,U)&&o(this,wt,Rt).call(this),t(this,U)&&(F||t(this,St).call(this,b,h,n),f&&t(this,J).call(this,f,b)),!r&&t(this,W)&&t(this,z)){const d=t(this,z);let y;for(;y=d==null?void 0:d.shift();)(v=t(this,H))==null||v.call(this,...y)}return this}pop(){var e;try{for(;t(this,O);){const i=t(this,u)[t(this,C)];if(o(this,dt,Ft).call(this,!0),o(this,p,w).call(this,i)){if(i.__staleWhileFetching)return i.__staleWhileFetching}else if(i!==void 0)return i}}finally{if(t(this,W)&&t(this,z)){const i=t(this,z);let s;for(;s=i==null?void 0:i.shift();)(e=t(this,H))==null||e.call(this,...s)}}}has(e,i={}){const{updateAgeOnHas:s=this.updateAgeOnHas,status:h}=i,n=t(this,m).get(e);if(n!==void 0){const r=t(this,u)[n];if(o(this,p,w).call(this,r)&&r.__staleWhileFetching===void 0)return!1;if(t(this,G).call(this,n))h&&(h.has="stale",t(this,J).call(this,h,n));else return s&&t(this,rt).call(this,n),h&&(h.has="hit",t(this,J).call(this,h,n)),!0}else h&&(h.has="miss");return!1}peek(e,i={}){const{allowStale:s=this.allowStale}=i,h=t(this,m).get(e);if(h===void 0||!s&&t(this,G).call(this,h))return;const n=t(this,u)[h];return o(this,p,w).call(this,n)?n.__staleWhileFetching:n}async fetch(e,i={}){const{allowStale:s=this.allowStale,updateAgeOnGet:h=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,ttl:r=this.ttl,noDisposeOnSet:l=this.noDisposeOnSet,size:f=0,sizeCalculation:F=this.sizeCalculation,noUpdateTTL:I=this.noUpdateTTL,noDeleteOnFetchRejection:b=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:K=this.allowStaleOnFetchRejection,ignoreFetchAbort:j=this.ignoreFetchAbort,allowStaleOnFetchAbort:X=this.allowStaleOnFetchAbort,context:A,forceRefresh:v=!1,status:d,signal:y}=i;if(!t(this,st))return d&&(d.fetch="get"),this.get(e,{allowStale:s,updateAgeOnGet:h,noDeleteOnStaleGet:n,status:d});const D={allowStale:s,updateAgeOnGet:h,noDeleteOnStaleGet:n,ttl:r,noDisposeOnSet:l,size:f,sizeCalculation:F,noUpdateTTL:I,noDeleteOnFetchRejection:b,allowStaleOnFetchRejection:K,allowStaleOnFetchAbort:X,ignoreFetchAbort:j,status:d,signal:y};let E=t(this,m).get(e);if(E===void 0){d&&(d.fetch="miss");const N=o(this,gt,Ot).call(this,e,E,D,A);return N.__returned=N}else{const N=t(this,u)[E];if(o(this,p,w).call(this,N)){const Ut=s&&N.__staleWhileFetching!==void 0;return d&&(d.fetch="inflight",Ut&&(d.returnedStale=!0)),Ut?N.__staleWhileFetching:N.__returned=N}const nt=t(this,G).call(this,E);if(!v&&!nt)return d&&(d.fetch="hit"),o(this,lt,pt).call(this,E),h&&t(this,rt).call(this,E),d&&t(this,J).call(this,d,E),N;const Q=o(this,gt,Ot).call(this,e,E,D,A),xt=Q.__staleWhileFetching!==void 0&&s;return d&&(d.fetch=nt?"stale":"refresh",xt&&nt&&(d.returnedStale=!0)),xt?Q.__staleWhileFetching:Q.__returned=Q}}get(e,i={}){const{allowStale:s=this.allowStale,updateAgeOnGet:h=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,status:r}=i,l=t(this,m).get(e);if(l!==void 0){const f=t(this,u)[l],F=o(this,p,w).call(this,f);return r&&t(this,J).call(this,r,l),t(this,G).call(this,l)?(r&&(r.get="stale"),F?(r&&s&&f.__staleWhileFetching!==void 0&&(r.returnedStale=!0),s?f.__staleWhileFetching:void 0):(n||this.delete(e),r&&s&&(r.returnedStale=!0),s?f:void 0)):(r&&(r.get="hit"),F?f.__staleWhileFetching:(o(this,lt,pt).call(this,l),h&&t(this,rt).call(this,l),f))}else r&&(r.get="miss")}delete(e){var s,h,n,r;let i=!1;if(t(this,O)!==0){const l=t(this,m).get(e);if(l!==void 0)if(i=!0,t(this,O)===1)this.clear();else{t(this,ot).call(this,l);const f=t(this,u)[l];if(o(this,p,w).call(this,f)?f.__abortController.abort(new Error("deleted")):(t(this,q)||t(this,W))&&(t(this,q)&&((s=t(this,P))==null||s.call(this,f,e,"delete")),t(this,W)&&((h=t(this,z))==null||h.push([f,e,"delete"]))),t(this,m).delete(e),t(this,S)[l]=void 0,t(this,u)[l]=void 0,l===t(this,T))a(this,T,t(this,x)[l]);else if(l===t(this,C))a(this,C,t(this,R)[l]);else{const F=t(this,x)[l];t(this,R)[F]=t(this,R)[l];const I=t(this,R)[l];t(this,x)[I]=t(this,x)[l]}At(this,O)._--,t(this,V).push(l)}}if(t(this,W)&&((n=t(this,z))!=null&&n.length)){const l=t(this,z);let f;for(;f=l==null?void 0:l.shift();)(r=t(this,H))==null||r.call(this,...f)}return i}clear(){var e,i,s;for(const h of o(this,Z,it).call(this,{allowStale:!0})){const n=t(this,u)[h];if(o(this,p,w).call(this,n))n.__abortController.abort(new Error("deleted"));else{const r=t(this,S)[h];t(this,q)&&((e=t(this,P))==null||e.call(this,n,r,"delete")),t(this,W)&&((i=t(this,z))==null||i.push([n,r,"delete"]))}}if(t(this,m).clear(),t(this,u).fill(void 0),t(this,S).fill(void 0),t(this,U)&&t(this,$)&&(t(this,U).fill(0),t(this,$).fill(0)),t(this,B)&&t(this,B).fill(0),a(this,C,0),a(this,T,0),t(this,V).length=0,a(this,k,0),a(this,O,0),t(this,W)&&t(this,z)){const h=t(this,z);let n;for(;n=h==null?void 0:h.shift();)(s=t(this,H))==null||s.call(this,...n)}}};qt=Symbol.toStringTag,M=new WeakMap,L=new WeakMap,P=new WeakMap,H=new WeakMap,ct=new WeakMap,O=new WeakMap,k=new WeakMap,m=new WeakMap,S=new WeakMap,u=new WeakMap,R=new WeakMap,x=new WeakMap,C=new WeakMap,T=new WeakMap,V=new WeakMap,z=new WeakMap,B=new WeakMap,$=new WeakMap,U=new WeakMap,q=new WeakMap,st=new WeakMap,W=new WeakMap,wt=new WeakSet,Rt=function(){const e=new mt(t(this,M)),i=new mt(t(this,M));a(this,U,e),a(this,$,i),a(this,St,(n,r,l=at.now())=>{if(i[n]=r!==0?l:0,e[n]=r,r!==0&&this.ttlAutopurge){const f=setTimeout(()=>{t(this,G).call(this,n)&&this.delete(t(this,S)[n])},r+1);f.unref&&f.unref()}}),a(this,rt,n=>{i[n]=e[n]!==0?at.now():0}),a(this,J,(n,r)=>{if(e[r]){const l=e[r],f=i[r];if(!l||!f)return;n.ttl=l,n.start=f,n.now=s||h();const F=n.now-f;n.remainingTTL=l-F}});let s=0;const h=()=>{const n=at.now();if(this.ttlResolution>0){s=n;const r=setTimeout(()=>s=0,this.ttlResolution);r.unref&&r.unref()}return n};this.getRemainingTTL=n=>{const r=t(this,m).get(n);if(r===void 0)return 0;const l=e[r],f=i[r];if(!l||!f)return 1/0;const F=(s||h())-f;return l-F},a(this,G,n=>{const r=i[n],l=e[n];return!!l&&!!r&&(s||h())-r>l})},rt=new WeakMap,J=new WeakMap,St=new WeakMap,G=new WeakMap,zt=new WeakSet,Ht=function(){const e=new mt(t(this,M));a(this,k,0),a(this,B,e),a(this,ot,i=>{a(this,k,t(this,k)-e[i]),e[i]=0}),a(this,_t,(i,s,h,n)=>{if(o(this,p,w).call(this,s))return 0;if(!tt(h))if(n){if(typeof n!="function")throw new TypeError("sizeCalculation must be a function");if(h=n(s,i),!tt(h))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}else throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");return h}),a(this,ut,(i,s,h)=>{if(e[i]=s,t(this,L)){const n=t(this,L)-e[i];for(;t(this,k)>n;)o(this,dt,Ft).call(this,!0)}a(this,k,t(this,k)+e[i]),h&&(h.entrySize=s,h.totalCalculatedSize=t(this,k))})},ot=new WeakMap,ut=new WeakMap,_t=new WeakMap,Y=new WeakSet,et=function*({allowStale:e=this.allowStale}={}){if(t(this,O))for(let i=t(this,T);!(!o(this,bt,Wt).call(this,i)||((e||!t(this,G).call(this,i))&&(yield i),i===t(this,C)));)i=t(this,x)[i]},Z=new WeakSet,it=function*({allowStale:e=this.allowStale}={}){if(t(this,O))for(let i=t(this,C);!(!o(this,bt,Wt).call(this,i)||((e||!t(this,G).call(this,i))&&(yield i),i===t(this,T)));)i=t(this,R)[i]},bt=new WeakSet,Wt=function(e){return e!==void 0&&t(this,m).get(t(this,S)[e])===e},dt=new WeakSet,Ft=function(e){var n,r;const i=t(this,C),s=t(this,S)[i],h=t(this,u)[i];return t(this,st)&&o(this,p,w).call(this,h)?h.__abortController.abort(new Error("evicted")):(t(this,q)||t(this,W))&&(t(this,q)&&((n=t(this,P))==null||n.call(this,h,s,"evict")),t(this,W)&&((r=t(this,z))==null||r.push([h,s,"evict"]))),t(this,ot).call(this,i),e&&(t(this,S)[i]=void 0,t(this,u)[i]=void 0,t(this,V).push(i)),t(this,O)===1?(a(this,C,a(this,T,0)),t(this,V).length=0):a(this,C,t(this,R)[i]),t(this,m).delete(s),At(this,O)._--,i},gt=new WeakSet,Ot=function(e,i,s,h){const n=i===void 0?void 0:t(this,u)[i];if(o(this,p,w).call(this,n))return n;const r=new Tt,{signal:l}=s;l==null||l.addEventListener("abort",()=>r.abort(l.reason),{signal:r.signal});const f={signal:r.signal,options:s,context:h},F=(A,v=!1)=>{const{aborted:d}=r.signal,y=s.ignoreFetchAbort&&A!==void 0;if(s.status&&(d&&!v?(s.status.fetchAborted=!0,s.status.fetchError=r.signal.reason,y&&(s.status.fetchAbortIgnored=!0)):s.status.fetchResolved=!0),d&&!y&&!v)return b(r.signal.reason);const D=j;return t(this,u)[i]===j&&(A===void 0?D.__staleWhileFetching?t(this,u)[i]=D.__staleWhileFetching:this.delete(e):(s.status&&(s.status.fetchUpdated=!0),this.set(e,A,f.options))),A},I=A=>(s.status&&(s.status.fetchRejected=!0,s.status.fetchError=A),b(A)),b=A=>{const{aborted:v}=r.signal,d=v&&s.allowStaleOnFetchAbort,y=d||s.allowStaleOnFetchRejection,D=y||s.noDeleteOnFetchRejection,E=j;if(t(this,u)[i]===j&&(!D||E.__staleWhileFetching===void 0?this.delete(e):d||(t(this,u)[i]=E.__staleWhileFetching)),y)return s.status&&E.__staleWhileFetching!==void 0&&(s.status.returnedStale=!0),E.__staleWhileFetching;if(E.__returned===E)throw A},K=(A,v)=>{var y;const d=(y=t(this,ct))==null?void 0:y.call(this,e,n,f);d&&d instanceof Promise&&d.then(D=>A(D===void 0?void 0:D),v),r.signal.addEventListener("abort",()=>{(!s.ignoreFetchAbort||s.allowStaleOnFetchAbort)&&(A(void 0),s.allowStaleOnFetchAbort&&(A=D=>F(D,!0)))})};s.status&&(s.status.fetchDispatched=!0);const j=new Promise(K).then(F,I),X=Object.assign(j,{__abortController:r,__staleWhileFetching:n,__returned:void 0});return i===void 0?(this.set(e,X,{...f.options,status:void 0}),i=t(this,m).get(e)):t(this,u)[i]=X,X},p=new WeakSet,w=function(e){if(!t(this,st))return!1;const i=e;return!!i&&i instanceof Promise&&i.hasOwnProperty("__staleWhileFetching")&&i.__abortController instanceof Tt},yt=new WeakSet,Dt=function(e,i){t(this,x)[i]=e,t(this,R)[e]=i},lt=new WeakSet,pt=function(e){e!==t(this,T)&&(e===t(this,C)?a(this,C,t(this,R)[e]):o(this,yt,Dt).call(this,t(this,x)[e],t(this,R)[e]),o(this,yt,Dt).call(this,t(this,T),e),a(this,T,e))};let It=Lt;export{It as L};
